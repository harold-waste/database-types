{"version":3,"sources":["../../src/queries/getDatabaseTableColumns.js"],"names":["connection","schema","any","sql"],"mappings":";;;;;;AAEA;;;;;8BAQe,WAAOA,UAAP,EAA2CC,MAA3C,EAA+G;AAC5H,SAAOD,WAAWE,GAAX,CAAeC,aAAI;;;;;;;;;;;;;;;;;;;;;4BAqBAF,MAAO;;;;;;;;;;;;;;;;;;;;gCAoBHA,MAAO;;;;;;;;;;;;;;gFAcyCA,MAAO;;2BAE5DA,MAAO;GAzDzB,CAAP;AA2DD,E","file":"getDatabaseTableColumns.js","sourcesContent":["// @flow\n\nimport {\n  sql\n} from 'mightyql';\nimport type {\n  DatabaseConnectionType,\n  UnnormalizedColumnType\n} from '../types';\n\nexport default async (connection: DatabaseConnectionType, schema: string): Promise<$ReadOnlyArray<UnnormalizedColumnType>> => {\n  return connection.any(sql`\n    SELECT\n      col.table_name \"tableName\",\n      col.column_name \"columnName\",\n      col.is_nullable \"isNullable\",\n      col.data_type \"dataType\",\n      tco.constraint_type \"constraintType\",\n      pgc.\"constraintDef\",\n      rc.\"refTableName\",\n      rc.\"refTableColumn\"\nFROM information_schema.columns col\nleft join (\n    select kcu.table_schema,\n       kcu.table_name,\n       kcu.column_name,\n       tco.constraint_type\n\tfrom information_schema.table_constraints tco\n\tjoin information_schema.key_column_usage kcu \n\t\t on kcu.constraint_name = tco.constraint_name\n\t\t and kcu.constraint_schema = tco.constraint_schema\n\t\t and kcu.constraint_name = tco.constraint_name\n\twhere kcu.table_schema = ${schema} and (tco.constraint_type = 'PRIMARY KEY' or tco.constraint_type = 'FOREIGN KEY')\n) as tco on tco.table_name = col.table_name and tco.column_name = col.column_name and tco.table_schema = col.table_schema\nleft join (\n\tselect\n\t\tkcu1.table_schema as table_schema,\n\t\tkcu1.table_name as table_name,\n\t\tkcu1.column_name as column_name,\n\t\tkcu2.table_name as \"refTableName\",\n\t\tkcu2.column_name as \"refTableColumn\"\n\tfrom\n\t\tinformation_schema.referential_constraints as rc\n\tinner join information_schema.key_column_usage as kcu1 on\n\t\tkcu1.constraint_catalog = rc.constraint_catalog\n\t\tand kcu1.constraint_schema = rc.constraint_schema\n\t\tand kcu1.constraint_name = rc.constraint_name\n\tinner join information_schema.key_column_usage as kcu2 on\n\t\tkcu2.constraint_catalog = rc.unique_constraint_catalog\n\t\tand kcu2.constraint_schema = rc.unique_constraint_schema\n\t\tand kcu2.constraint_name = rc.unique_constraint_name\n\t\tand kcu2.ordinal_position = kcu1.ordinal_position\n\twhere rc.constraint_schema = ${schema}\n) as rc on rc.table_name = col.table_name and rc.column_name = col.column_name and rc.table_schema = col.table_schema\nleft join (\n\tselect pgc.conname as constraint_name,\n\t       ccu.table_schema as table_schema,\n\t       ccu.table_name,\n\t       ccu.column_name,\n\t       pg_get_constraintdef(pgc.oid) as \"constraintDef\"\n\tfrom pg_constraint pgc\n\tjoin pg_namespace nsp on nsp.oid = pgc.connamespace\n\tjoin pg_class  cls on pgc.conrelid = cls.oid\n\tleft join information_schema.constraint_column_usage ccu\n      on pgc.conname = ccu.constraint_name\n      and nsp.nspname = ccu.constraint_schema\n    where pg_get_constraintdef(pgc.oid) like '%ARRAY%' and ccu.table_schema = ${schema}\n) as pgc on pgc.table_name = col.table_name and pgc.column_name = col.column_name and pgc.table_schema = col.table_schema\nWHERE col.table_schema = ${schema}\n  `);\n};\n"]}